## 다이나믹 프로그래밍(Dynamic Programming)
동적 계획법이라고도 불리고, 다이나믹이라는 단어는 기법과 아무 상관 없다. 만든 사람은 이름이 멋있어 보여서 붙였다고 한다. 한글 번역, 동적 계획법도 덩달아 Dynamic이 반영됬는데, 더 적절한 해석으로는 "기억하며 풀기"가 있다.  


동적 계획법은 별 거 없다. 겹치는 부분 문제를 기억하며 풀고, 문제를 또 불러올 때 기억한 해답을 반환함으로써 실행 시간을 줄인다.

예를 들면 피보나치 수열을 생각해보자. `fibo(n)=fibo(n-1)+fibo(n-2)`인건 누구나 안다. `fibo(5)` 실행하면 아래 그림처럼 연속적으로 실행된다.
![fibo](https://blogfiles.pstatic.net/20160801_275/kks227_14700305083805XBuM_GIF/complexityRecursion_1.gif?type=w3)

잘 보면 아래 그림에서 빨간색이 겹친다. `fibo(3)`을 한 번 실행했는데 또 `fibo(3)`을 실행하며 아래로 따라 내려갈 필요가 없다. `fibo(3)`을 한 번 실행하면, 반환값을 저장했다가 나중에 또 `fibo(3)`이 호출되면 저장된 값을 바로 반환하자.
![fibo2](https://blogfiles.pstatic.net/20160801_6/kks227_1470036505144Mg9j4_GIF/complexityRecursion_1.gif?type=w3)

`fibo(30)`을 실행하면 동적 계획법을 사용하지 않으면, 세부 구현에 따라 달라질 수 있지만 일단 `fibo(1)`은 80만번 호출된다. 동적 계획법을 적절히 사용하면 `fibo(1)`는 한번만 호출된다. `fibo(10)`을 실행할 때 호출되는 함수들을 트리 모양으로 위 그림처럼 그려보면 얼마나 중복되는 부분이 많은지 알 수 있다.


#### 피보나치

**상태 정의**
`dp[i]=i번째 피보나치 수`, 편의상 dp[0]=dp[1]=1으로 한다.

**점화식**
`dp[i]=dp[i-1]+dp[i-2]`

**소스**
without DP
```python
def fibo(n):
	if n<2: return 1
	return fibo(n-1)+fibo(n-2)
```
with DP
```python
dp=[0]*1000
def fibo(n):
	if n<2: return 1
	if dp[n]: return dp[n]
	dp[n]=fibo(n-1)+fibo(n-2)
	return dp[n]
```


#### 1로 만들기 BOJ 1463

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

**상태 정의**
`dp[n]=n에 연산 3개를 사용해서 1을 만들 때 필요한 연산 횟수의 최솟값`

**점화식**
`dp[n]=min(dp[n-1],dp[n/2],dp[n/3])+1`
n/2, n/3은 각각 n이 2의 배수, 3의 배수일때만 실행하면 된다
자세한건 아래 소스로 보자

**소스**
without DP
```python
INF=10**9
elements=[2,3]
def solve(n):
	if n==1: return 0
	ret=INF
	for i in elements:
		if n%i==0:
			ret=min(ret, solve(n//i))
	return min(ret,solve(n-1))+1
```

with DP
```python
INF=10**9
elements=[2,3]
dp=[0]*1000005
def solve(n):
	if n==1: return 0
	if dp[n]: return dp[n]
	ret=INF
	for i in elements:
		if n%i==0:
			ret=min(ret, solve(n//i))
	dp[n]=min(ret,solve(n-1))+1
	return dp[n]
```

### 연습문제

##### 1. BOJ 10844 쉬운 계단 수
45656이란 수를 보자.

이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.

세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

**상태 정의**
`dp[n][last]=______________________`

**점화식**
```
dp[n][0]=______________________
dp[n][1부터 9까지 정수 last]=______________________
dp[n][9]=______________________
```

##### 2. BOJ 1912 연속합
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.

**상태 정의**
`______________________`

**점화식**
```
____________________________________________
```

DP를 쓰지 않고도 풀 수 있다. Kadane Algorithm, 연속합 알고리즘이 따로 있다.
